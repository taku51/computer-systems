Sender and receiver know the same secret key in symmetric systems. Therefore, the same secret key is 
used for both encryption and decryption.

-> sender chooses a secret key to encrypt a plain text, and the recipent uses the same key to decrypt the cipher text.

Encryption and decryption keys are different in public key systems. The encryption key is known by everyone including the sender, 
but the decryption key is only known by the receiver.

-> Receiver first creates its own public and private keys, where the former is open to everyone but the latter is hidden.
Sender uses the former (public key created by the receiver, which is open to everyone) to encrypt a plain text. 
Recipent can decrypt and open the cyphertext encrypted using the public key by sender, with its private key.

If N people want to communicate with each of N-1 other people using symmetric key encryption, each pair of users must have a
shared symmetric key, that is N * (N-1) / 2 keys.

-> N people want to communicate with N-1 other people, and symmetric key encryption uses the same secret key for both encryption
and decrypiton, so N * N -1. Since we only need the same key for one pair, remove duplicates by diving it by 2.

With a public key system (also known as assymetric crypto)

-> Everyone user should have two keys, including one public key which is open to 
everyone and the other which is onlu known by the user. Anyone can use the user's public key to encrypt a plain text, and 
the user can use its own private key to decrypt the cyphertext.

Therefore, every user would need 2 keys for encryption and decryption.
So 2N keys required.

AES is an symmetric cryptography algo'. 
-> The same secret key is used for encryption and decryption. 
Key to sign is the same as the key to verify

AES is less suitable for digital signatures than RSA (public key systems).
-> It is less suitable because digital signatures should only be forged or created by one user, but
in symmetric system, it uses the same secret key, and thus can be used for both verification and creation of signatures.

Asymmetric key crypto is not used to encrypt actual messages.
-> Because it is slower than symmetric. Not suitable for encrypting large amounts of data. Can
only encrypt data up to the sie of the key. As it needs to first encrypt using the public key(which is open to everyone 
and private key to decrypt, where as with symmetric can just use a single key for both, which simplifies
the entire system)

Asymmetric key crypto (public key system. Different keys for encryption and decryption) is 
usually used with symmetric key crypto to encrypt messages.
-> it is used to exchanging a joint secret key for symmetric system.

The entire process would look like
Alice generates her key pair and posts her public key online.
Bob generates a secret key and encrypts his secret key using Alice's public key (public key is always
used to encrypt in public key system)
Bob sends the encrypted text to Alice
Alice uses her own private key to decrypt Bob's encrypted secret key.
Now Alice and Bob share the secret key. This means that secret key is shared in an encrypted way,
and the key can be used as the key for both encryption and decryption of messages between alice and bob.

Degital Ceritifcate is the fundamental job of a certificate in order to bind a public key to 
the name of someone (individual or company). 
It includes details about the owner, information about the public
key, and the signature of the certifying authority.

-> It is a set of information including the public key, owner, and the digital signature.

Suppose certifier.com creates a certificate for foo.com. The entire certificate would be encrypted with 
certifier.com's public key. 

-> False. Ceritifcates need to be distinct so needs to include some data of foo.com, which could be 
a hash of foo.com's information (including its public key), and signed with certifier.com's private key.
As public key is always open to everyone. Needs to sign with private key to certify.

Diffie Hellman key exchange is used for sharing a secret key between two users. p and g are already fixed.
*g must be smaller than p. Because it's modulo p. P must be a prime number.
The secret key chosen by each user is user to power g. e.g. if secret key is 4. g^4 but p always stays
the same, and it's used for modulo p.

Alice and Bob share the secret key as follows:
Alice sends p, g and A's computed public key (g^x mod p where is a secret key) in the tuple
(227, 5, 82), where x = 12. 

Bob finds x by reverse engineering
the g^x mod p sent by Alice, this can be done by manually inserting a value into x
until it finds a value 82, 5^x mod 227 = 82). -> Bob now has Alice's secret key.

Bob sends 125 (g^y mod p) where y is the secret key Bob chose = 3.

Alice sends g^b^a mod p = 5^12^3 mod 227 = 212, after doing the same step as Bob did to find her secret key.

The secret key in the endis g^b^a mod p = 5^12^3 mod 227

RSA asymmetric cryptography uses powers of large numbers modulo a third number, like
Diffie-Hellman key exchange. 

-> Encryption consists of calculating m^e(mod n).
e and n are the variables and m is the plaintext.

-> Decrypting ciphertext c consists of calculating c^d (mod n) 
private key consits d and n excluding the cyphertext

-> always decrypt to the correct plaintext.
e.g. encrypt the message 6 with the key (e = 3, n=55, they are any integers)
Decrypt the cipher text with (d=7, n=55). n has to be the same but d can be any secret integer.
The decoded message is ciphertext^decryption key ≡ plaintext^encrption key^decryption key ≡ 
Original message.


Alice wants to communicate with Bob, using public-key system (assymetric, public key and private key). 
She establishes a connection to someone she hopes is Bob. Alice gets Bob's public key(encryption key) through
plaintext along with an X.509 certificate signed by the root CA. 
Alice already has the public key of the root CA. 

-> Alice checks if it's Bob by Step 1 is to verify the X.509 certicate using the root CAs public key (
alrady has the public key of the root CA and needs to verify the bob's public using the x.509 certificate). 
If it is genuine, she now has Bob’s public key, although she should check the CRL (certificate revocation list) if
there is one. 

-> To see if it is Bob on the other end of the connection, she needs to know
if Bob has the corresponding private key. She picks a nonce (essentially a random number
used once) and sends it to him with his public key. If Bob can send it back in plaintext, she
is convinced that it is Bob. As Bob needs to decrypt with his private key.
So all she needs is use Bob's public to encrypt that is done through¥ the certificate, and then send a 
random number in an encrypted way and let him decrypt.

In, PKI based on a tree-structured hierarchy of CAs, Alice wants
to communicate with Bob, and receives a certificate from Bob signed by a CA X after
establishing a communication channel with Bob. Alice has never heard of X.

-> First Alice establishes a communication channel with X and asks X for a certificate to verify
his public key (when verifying
always need to first verify the authority of the certificate, public key)
X provides a certificate signed by another CA Y. Alice does not
know Y, she first does it with Y.
Alice continues to do this, until she receives a certificate verifying the public key of a CA
Z signed by A and Alice knows As public key. 
After this Alice verifies the public keys in reverse order
starting from the certificate that Z provided. In each step during verification, she also checks
the CRL to make sure that the certificate provided have not been revoked. Finally, after
verifying Bobs public key, Alice ensures that she is indeed talking to Bob using the same
method as in the previous problem.

Salt can be addded to plaintext in the following ways:
The salt could be arithmetically added to the plaintext, 
treating both binary strings as numbers. A con is that this requires carry over many bytes.

The salt could be appended or prepended to the plaintext. An advantage is that this works
with arbitrary length plaintexts. A disadvantage is that this makes the plaintext longer, which
increases computation of encryption and decryption substantially. 
If the text is in block shape, then some blocks may not be protected at all.

Describe the TLS (transport layer security, responsible for the authentication and key exchange 
necessary to establish) Handshake process.
(a) First TCP connection (always need a TCP connection to begin with, otherwise no connection between them)
(b) Client (always start with a client) sends clienthello and asks the server for secure connection,
listing its supported cipher suites (signature, encryption method and so on).
(c) Server responds with ServerHello and selects one of the cipher
suites presented that it supports, also includes its certificate, and
can request the client send its certificate (mutual authentication)
(d) Client confirms validity of certificate (receving the server certificate) Once the certificates are valid, do key exchange
(e) Client generates session key -> can do in two ways
i. Picking a random key and encrypting it with the public key of the
server (alway use the opponet's public key to encrypt)
ii. Running the Diffie-Hellman Key Exchange protocol that provides better security
(f ) Handshake concludes and both parties share a key that is then used for encrypting/decrypting
messages

