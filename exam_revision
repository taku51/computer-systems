week 8

Sender and receiver know the same secret key in symmetric systems. Therefore, the same secret key is 
used for both encryption and decryption.

-> sender chooses a secret key to encrypt a plain text, and the recipent uses the same key to decrypt the cipher text.

Encryption and decryption keys are different in public key systems. The encryption key is known by everyone including the sender, 
but the decryption key is only known by the receiver.

-> Receiver first creates its own public and private keys, where the former is open to everyone but the latter is hidden.
Sender uses the former (public key created by the receiver, which is open to everyone) to encrypt a plain text. 
Recipent can decrypt and open the cyphertext encrypted using the public key by sender, with its private key.

If N people want to communicate with each of N-1 other people using symmetric key encryption, each pair of users must have a
shared symmetric key, that is N * (N-1) / 2 keys.

-> N people want to communicate with N-1 other people, and symmetric key encryption uses the same secret key for both encryption
and decrypiton, so N * N -1. Since we only need the same key for one pair, remove duplicates by diving it by 2.

With a public key system (also known as assymetric crypto)

-> Everyone user should have two keys, including one public key which is open to 
everyone and the other which is onlu known by the user. Anyone can use the user's public key to encrypt a plain text, and 
the user can use its own private key to decrypt the cyphertext.

Therefore, every user would need 2 keys for encryption and decryption.
So 2N keys required.

AES is an symmetric cryptography algo'. 
-> The same secret key is used for encryption and decryption. 
Key to sign is the same as the key to verify

AES is less suitable for digital signatures than RSA (public key systems).
-> It is less suitable because digital signatures should only be forged or created by one user, but
in symmetric system, it uses the same secret key, and thus can be used for both verification and creation of signatures.

Asymmetric key crypto is not used to encrypt actual messages.
-> Because it is slower than symmetric. Not suitable for encrypting large amounts of data. Can
only encrypt data up to the sie of the key. As it needs to first encrypt using the public key(which is open to everyone 
and private key to decrypt, where as with symmetric can just use a single key for both, which simplifies
the entire system)

Asymmetric key crypto (public key system. Different keys for encryption and decryption) is 
usually used with symmetric key crypto to encrypt messages.
-> it is used to exchanging a joint secret key for symmetric system.

The entire process would look like
Alice generates her key pair and posts her public key online.
Bob generates a secret key and encrypts his secret key using Alice's public key (public key is always
used to encrypt in public key system)
Bob sends the encrypted text to Alice
Alice uses her own private key to decrypt Bob's encrypted secret key.
Now Alice and Bob share the secret key. This means that secret key is shared in an encrypted way,
and the key can be used as the key for both encryption and decryption of messages between alice and bob.

Degital Ceritifcate is the fundamental job of a certificate in order to bind a public key to 
the name of someone (individual or company). 
It includes details about the owner, information about the public
key, and the signature of the certifying authority.

-> It is a set of information including the public key, owner, and the digital signature.

Suppose certifier.com creates a certificate for foo.com. The entire certificate would be encrypted with 
certifier.com's public key. 

-> False. Ceritifcates need to be distinct so needs to include some data of foo.com, which could be 
a hash of foo.com's information (including its public key), and signed with certifier.com's private key.
As public key is always open to everyone. Needs to sign with private key to certify.

Diffie Hellman key exchange is used for sharing a secret key between two users. p and g are already fixed.
*g must be smaller than p. Because it's modulo p. P must be a prime number.
The secret key chosen by each user is user to power g. e.g. if secret key is 4. g^4 but p always stays
the same, and it's used for modulo p.

Alice and Bob share the secret key as follows:
Alice sends p, g and A's computed public key (g^x mod p where is a secret key) in the tuple
(227, 5, 82), where x = 12. 

Bob finds x by reverse engineering
the g^x mod p sent by Alice, this can be done by manually inserting a value into x
until it finds a value 82, 5^x mod 227 = 82). -> Bob now has Alice's secret key.

Bob sends 125 (g^y mod p) where y is the secret key Bob chose = 3.

Alice sends g^b^a mod p = 5^12^3 mod 227 = 212, after doing the same step as Bob did to find her secret key.

The secret key in the endis g^b^a mod p = 5^12^3 mod 227

RSA asymmetric cryptography uses powers of large numbers modulo a third number, like
Diffie-Hellman key exchange. 

-> Encryption consists of calculating m^e(mod n).
e and n are the variables and m is the plaintext.

-> Decrypting ciphertext c consists of calculating c^d (mod n) 
private key consits d and n excluding the cyphertext

-> always decrypt to the correct plaintext.
e.g. encrypt the message 6 with the key (e = 3, n=55, they are any integers)
Decrypt the cipher text with (d=7, n=55). n has to be the same but d can be any secret integer.
The decoded message is ciphertext^decryption key ≡ plaintext^encrption key^decryption key ≡ 
Original message.


Alice wants to communicate with Bob, using public-key system (assymetric, public key and private key). 
She establishes a connection to someone she hopes is Bob. Alice gets Bob's public key(encryption key) through
plaintext along with an X.509 certificate signed by the root CA. 
Alice already has the public key of the root CA. 

-> Alice checks if it's Bob by Step 1 is to verify the X.509 certicate using the root CAs public key (
alrady has the public key of the root CA and needs to verify the bob's public using the x.509 certificate). 
If it is genuine, she now has Bob’s public key, although she should check the CRL (certificate revocation list) if
there is one. 

-> To see if it is Bob on the other end of the connection, she needs to know
if Bob has the corresponding private key. She picks a nonce (essentially a random number
used once) and sends it to him with his public key. If Bob can send it back in plaintext, she
is convinced that it is Bob. As Bob needs to decrypt with his private key.
So all she needs is use Bob's public to encrypt that is done through¥ the certificate, and then send a 
random number in an encrypted way and let him decrypt.

In, PKI based on a tree-structured hierarchy of CAs, Alice wants
to communicate with Bob, and receives a certificate from Bob signed by a CA X after
establishing a communication channel with Bob. Alice has never heard of X.

-> First Alice establishes a communication channel with X and asks X for a certificate to verify
his public key (when verifying
always need to first verify the authority of the certificate, public key)
X provides a certificate signed by another CA Y. Alice does not
know Y, she first does it with Y.
Alice continues to do this, until she receives a certificate verifying the public key of a CA
Z signed by A and Alice knows As public key. 
After this Alice verifies the public keys in reverse order
starting from the certificate that Z provided. In each step during verification, she also checks
the CRL to make sure that the certificate provided have not been revoked. Finally, after
verifying Bobs public key, Alice ensures that she is indeed talking to Bob using the same
method as in the previous problem.

Salt can be addded to plaintext in the following ways:
The salt could be arithmetically added to the plaintext, 
treating both binary strings as numbers. A con is that this requires carry over many bytes.

The salt could be appended or prepended to the plaintext. An advantage is that this works
with arbitrary length plaintexts. A disadvantage is that this makes the plaintext longer, which
increases computation of encryption and decryption substantially. 
If the text is in block shape, then some blocks may not be protected at all.

Describe the TLS (transport layer security, responsible for the authentication and key exchange 
necessary to establish) Handshake process.
(a) First TCP connection (always need a TCP connection to begin with, otherwise no connection between them)
(b) Client (always start with a client) sends clienthello and asks the server for secure connection,
listing its supported cipher suites (signature, encryption method and so on).
(c) Server responds with ServerHello and selects one of the cipher
suites presented that it supports, also includes its certificate, and
can request the client send its certificate (mutual authentication)
(d) Client confirms validity of certificate (receving the server certificate) Once the certificates are valid, do key exchange
(e) Client generates session key -> can do in two ways
i. Picking a random key and encrypting it with the public key of the
server (alway use the opponet's public key to encrypt)
ii. Running the Diffie-Hellman Key Exchange protocol that provides better security
(f ) Handshake concludes and both parties share a key that is then used for encrypting/decrypting
messages

---------------------------------------------------------------

week 9

Routers have IP addresses

-> One address for each router/interface typically. No two interfaces can have the same address, 
but possible to have multiple addresses or no IP address if it's not connected to the internet.

Two hosts have IP addresses 192.200.20.5 and 192.200.100.5.
(a) If each is on a /24 network, are they on the same network?

-> No. /24 = 24 bits. Read from the left. 3 decimals are used to represent 8.

(b) If each is on a /20 network, are they on the same network?
 
 -> No. /20 = 20 bits.

(c) If each is on a /17 network, are they on the same network?

-> Yes 17 bits reading from the left. Differ in 20 and 100 part.
This case break them down into binary from decimal. 20 = 1010 (16 + 4), 100 = 110010  (64 + 32 + 4)
so the first bit of those are the same, which means exactly 17 bits are the same.

(d) if each is on a /14 network, are they on the same network?

-> Yes reading decimals from the left, it's obviously true.


Datagram networks route each packet as a separate unit, independent of
all others, as the name says datagram (piece of data). 

In virtual-circuit networks, each data packet follows a predetermined route (as circuits are usually defined)
-> Virtual-circuit networks need the capability to route isolated
packets from an arbitrary source to an arbitrary destination, in order to
guide connection setup packets from an arbitrary source to an arbitrary
destination.

A network on the Internet has a subnet mask of 255.255.240.0. 

-> the maximum number of hosts it can handle is 4094.

Use HOST ID to calculate this. NET ID for 20, leave 12 bits for HOST ID (IP address is 32 bits, 4sets of 3 decimals)
NET ID is always 20. So 12 bits are available.

-> The binary representation of the subnet mask consists of 20 ones followed
by zeroes. Change the decimal to binary rep.
11111111_11111111_11110000_00000000

This means that the mask is 20 bits long, so the network part
is 20 bits. (The total/ip address is 32 bit long) 
The remaining 12 bits are for the host, so 2^12 = 4096 host addresses exist.
*It's the maximum num it can allocate.

A router received routes to the following new IP networks: 57.6.96.0/21,
57.6.104.0/21, 57.6.112.0/21, and 57.6.120.0/21. All of them are routed
on the same outgoing line. They can be aggregated.

-> They can be aggregated to 57.6.96.0/19 (the network parts of the addresses
that use the same outgoing line are the same up to 19 bits.)

*A Subnet mask is a 32-bit number that masks an IP address, 
and divides the IP address into network address and host address. Subnet musk has network and host address. 20 for network and 12 for the host.

Prefix: substring 21 bit system. But one set of decimals/decimal always have 8 bits.


57.6.96.0/21 00111001 00000110 01100000 00000000
57.6.104.0/21 00111001 00000110 01101000 00000000
57.6.112.0/21 00111001 00000110 01110000 00000000
57.6.120.0/21 00111001 00000110 01111000 00000000

Since it is the same until the third set of 011. It is the most optimal address.
So it has 19 bits and leave the rest zeros, and thus 57.6.96.0/19.

A large number of consecutive IP addresses are available starting at 198.16.0.0.
Four organizations, A, B, C, and D, request 4000, 2000, 4000,8000 addresses, 
respectively, and in that order. Each is allocated the lowest available IP addresses. 

The first IP address assigned, the last IP address assigned, and the mask in the
w.x.y.z/s notation of these are:
-> think how many bits it would need to request those numbers of addresses

A: 4000 addresses require 12 bits (2^10 = 1024, 1024 * 2 * 2 = 2^12), so 
198.16.0.0 – 198.16.15.255 (11000110.00010000.00001111.11111111, 12 bits extra 00001111 is 15
, 11111111 becomes 255) written as 198.16.0.0/20 (need 32 - 12 as it's the free part. so it becomes 198.16.0.0/20)

*reading binary (1010)2 can also be written as follows: (1 * 2^3) + (0 * 2^2) + (1 * 2^1) + (0 * 2^0)

B: 2000 addresses require 11 bits, so
198.16.16.0 – 198.16.23.255 written as (1024 * 2 = 2048, 11000110.00010000.00000111.11111111)
198.16.16.0/21 (-11 bits)

C: 4000 addresses require 12 bits, so (16, 32, 64 are because of the previous ranges already assigned for A and B
it goes up always a decimal value of 16 each time)
198.16.32.0 – 198.16.47.255 written as
198.16.32.0/20

D: 8000 addresses require 13 bits, so
198.16.64.0 – 198.16.95.255 written as
198.16.64.0/19

A router has the following (CIDR) entries in its routing table (it shows how routing should be done, where it goes):

Address/mask Next hop
135.46.56.0/22 Interface 0
135.46.60.0/22 Interface 1
192.53.40.0/23 Router 1
default Router 2

For each of the following IP addresses, the router passes to the next hop when a packet
with that address arrives.
(a) 135.46.63.10 -> interface 1 (as 135.46.60.0/22 covers 63.10)
(b) 135.46.57.14 -> interface 0 (135.46.60.0/22 covers 57.14)
(c) 135.46.52.2 -> router 2 (not covered by any of the ones in the routing table so go to the defualt one)
(d) 192.53.40.7 -> router 1 (Coveredd by 192.53.40.0/23)
(e) 192.53.56.7 -> router 2 (not covered by any of the ones in the routing table so go to the defualt one)


A host to send an IP packet with the wrong source IP address 
-> A host launching a denial-of-service attack may send packets with a spoofed
source address that corresponds to another host, in order to evade beig tracked out. -> to fake identity for denial
of service attack (DoS attack).


Two ways that this can adversely affect the legitimate
owner of that IP address are:

The legitimate owner may be blamed for the attack (exploited by the malicious entity.
blocked from sending legitimate traffic to the victim destination (get blacklisted)), and may
also receive unwanted return traffic (e.g., SYN-ACK or RST packets).


Consider a network with the following link costs. Find the shortest path
from A to B using Dijkstra’s algorithm.

\ A B C D E
A 0 – 1 2 4
B – 0 – 10 4
C 1 – 0 3 2
D 2 10 3 0 5
E 4 4 2 5 0

From A to B, so look at A first. As dijkstra follows the most optimal local path each turn, it first goes to
C. From C, E is the closest unvisited node so goes to E, and then B.
*it doesn't go to the same node again.

The shortest path is B-E-C-A.

The IP packet header includes a time-to-live field that is decremented by
each router along the path. (each turn it gets decremented)

-> The time-to-live field is necessary because a packet might get stuck in forwarding loop (e.g., due to a router configuration mistake, 
or the transients of a routing algorithm). By decrementing
the TTL (time to live) field at each hop, and discarding the packet when the TTL reaches 0, 
the network prevents the packet from being in an inifinate loop. 
Otherwise, it would consume excessive resources, or even escape the
loop eventually and reach the destination much later.

An ISP owns the block of addresses of the form 101.101.128.0/17.
It wants to create four subnets from this block, each block having
the same number of IP addresses. The prefixes (of form a.b.c.d/x)
for the four subnets are as follows: add 32 each time.

Four equalsize subnets:
need additional 2 digits to express 4 different patterns. So 17 ->19
101.101.128.0/17 single subnet 110.101.1(0000000.0/17)
so 
101.101.10000000.0/19 -> 101.101.128.0/19

101.101.10100000.0/19 -> 101.101.160.0/19

101.101.11000000.0/19 -> 101.101.192.0/19

101.101.11100000.0/19 -> 101.101.224.0/19


Consider the example of BGP (how the vendor map looks like, each of the nodes is an autonomous system):

(a) an Autonomous Sytem is a network that are collections of routers
under the same administrative control (network which contains routers under the same control system). 
e.g. ISP network. Customers A, B, C own autonomous systems.

(b) A physical path exists between AS2 and AS3,
as well as between AS3 and AS4. A packet sent from C with
destination A cannot be sent from AS4 to AS3 to AS2.
-> The customer ISP typically only advertises routes for their network to avoid transiting other traffic 
(in this case, traffic destined to A).So cannot transit to other tranffic.

------------------------------------------------------------------
week 10:


Sending a 1500-byte datagram into a link that has an MTU
(Maximum Transmission Unit) of 500 bytes. The original datagram is stamped with the identification number 1. Assume that IPv4 is
used. Hint: The IPv4 header is 20 bytes long.

Need to chunk into smaller because it's too big.

(a) Where does fragmentation happen? Where are the fragments reassembled?

ROuters with small MTU -> necessity for fragmentation.
Pkt re-assembled at the end hosts

(b) How many fragments are generated?

500 has 20 header and 480 data.
480 * 3 + 1

+ 1 is for anything else carrying
60 left so another one fragment needed.

4 fragments in total 

(c) In addition to the identification number, what are the fields in the
generated IP datagram(s) that are related to fragmentation?


(d) What are the values of the fragmentation-related fields in the generated IP datagram(s)?

DF = 0
First 3 fragments: MF = 1; 4th MF = 0
1st FO = 0; 2nd FO = 60; 3rd FO = 120; 4th FO = 180

480 / 8 bytes
960 / 8 bytes
...

2. John’s home network consists of his laptop, smart phone and smart speaker.
(a) Is it likely that each of these devices will each have unique global IP
address? Explain why or why not.



(b) The network address of the home network is 192.168.1.0/24. Assign
addresses to all interfaces in the home network.

Just allocate internal IPs to each of the devices
192.168.1.1

(c) Describe a widely used solution (as described in the lectures) which
allows several devices to share the same global IP address.

NAT - Network address transmission

(d) John is a keen computer science student who is writing his own web
server. Describe the key difficulty he will face when testing his server
which is related to the solution you described above, and describe a
workaround for the problem.

Once an external user initiated a connection to the web server -> 404
Manually set a NAT rule;: mapping internal web server

3. Explain the difference between an application layer proxy and a NAT box.

APP proxy:
  App -> proxy -> Destination
  Mapping external IP address to numbers of internal IP addresses

4. Why are acknowledgments used in 802.11 but not in wired Ethernet?

Wireless scenario: more likely losing pkts
wireless sender may not be capable listening and sending at same time.
Interference may occur without sender's awareness

5. If the duration of a packet is very much less than the propagation delay
(round-trip time) from one side of a network to the other, does CSMA
provide much performance benefit over Aloha? Why or why not?

No.
CSMA: listen before sending
While RTT super large when compared to pkt sending/resending:
Worse case: listening to the other end of network consuming a RTT

6. Which is “better”, Aloha or CSMA? Why?

ALOHA: simpler, but lower TP
CSMA: better performance, but more complicated implementation

Dependency on e.g. Hardware
  Only poor performance provided: ALOHA may beat CSMA

7. If CSMA was phased out of ethernet decades ago, why is it still used in
WiFi?

Wifi: based on broadcasting, manipulates over a shared medium
Ethernet: point to point connection, no need to severely negotiate with other hosts.



----------------------------------------------------------

week 11








------------------------------------------------------


Revision



-------------------------------------------------------

Mid-semester test
1. The Internet community (“TCP/IP model”) consider layers 5 and 6 to be “empty”; they do not add any processing, headers or messages. 
Is it possible for the network layer of a communication system to be empty?

(a) No, the network layer is the only layer of the stack that cannot be empty.
(b) Yes, a single point-to-point link like a USB cable can be seen as a communication system with no network layer
(c) Yes, the “network layer” refers to the actual network equipment (wires, routers), not a protocol
(d) No, without a network layer, data cannot go from one place to another

b ->　physical

2. What layer is DNS?
(a) Network; DNS concerns the naming of nodes, which is a network layer function
(b) Transport; DNS uses the network to provides service to the application layer, and so is a transport layer protocol
(c) Application; DNS is concerned with allowing the final application to use simple names
(d) Link; DNS provides a link between domain names and IP addresses

c -> ip to names but not link betw' names and IP addresses.

3. Which of the following is NOT a role of sockets in network programming?
(a) They are the interface between the transport layer and the application layer.
(b) A pair of sockets provides a connection between two peers at the application layer
(c) A socket can bypass the physical layer to allow an application to continue working when a cable gets cut.
(d) A socket can listen for attempts to connect to a particular TCP port.

c ->

4. What is multiplexing/demultiplexing, and how does it relate to the transport layer?
(a) Multiplexing/demultiplexing refers to sharing one resource between multiple uses; the transport demultiplexes a single network attachment (IP address) between multiple logical data flows
(b) Multiplexing/demultiplexing refers to being able to do more than one thing at once; the transport layer can send and receive data at the same time, which is a form of multiplexing
(c) Multiplexing/demultiplexing refers to requiring multiple numbers to identify something; a TCP connection is identified by (source address, source port, destination address, destination port)
(d) Multiplexing/demultiplexing refers to indexing things by sequence numbers; TCP uses multiplexing/demultiplexing to know which packets to retransmit when loss occurs

a ->

5. In SMTP, how does the receiver know when the header is finished?
(a) The header starts with a “Length” field saying how many bytes are in the header 
(b) The header starts with a “Length” field saying how many lines are in the header 
(c) The header ends with a “Bcc” field; after that is the message body
(d) The line after the header is the first blank line after the start of the message.

d ->

6. If an authoritative DNS server becomes unavailable, what happens?
(a) DNS will no longer work because no other DNS servers are authorized
(b) The hosts for which that server is authoritative will become unreachable, and all connec- tions to them will be broken
(c) Most things will keep working because the information in the authoritative server is prob- ably cached in other DNS servers, and an ongoing TCP connection does not need DNS
(d) DNS will stop working for the hosts for which this server is authoritative, but existing connections will continue.

c ->

7, Why are protocol “stacks” made of layers?
(a) Early designers wanted to break the coding tasks between teams, and the functionality assigned to each team is called a “layer”
(b) Layering is the only way to implement a network stack, because each module can only interact with two other modules
(c) Layering allows each protocol to hide some complexity from the higher layers to provide a simpler view of the network, but sometimes layers need to interact with layers they are not adjacent to
(d) A “layer” is any protocol that lays headers in front of packets; these headers are needed to tell other network entities what to do with the packet

c ->

8, TCP is a “reliable” protocol. That means
(a) It delivers to the receiver all of the packets that are sent by the sender
(b) TCP is not vulnerable to network devices that maliciously alter the contents of the data stream
(c) It doesn’t accidentally disconnect often; some implementations automatically reconnect if needed
(d) If packets are lost by the lower layers, it will keep retransmitting them until either they get through or the connection is broken

d ->

9. The URL foo://123.45.6.7/abc/def.jpg
(a) is not a valid URL
(b) is a valid URL telling a browser to contact host 123.45.6.7 with protocol “foo”
(c) says that there is a JPEG image file called def.jpg in folder abc at host 123.45.6.7 
(d) tells the browser to contact host 123.45.5.6 and try to access file abc/def.jpg

b -> 
If there's an IT address and protocol, can ignore the rest

10. HTTP can use persistent or non-persistent TCP connections.
(a) A non-persistent connection is a different type of TCP connection that doesn’t persist in retransmitting lost packets; these are better for streaming applications
(b) ApersistentTCPconnectionisatypeofTCPconnectionthatreconnectsiftheconnection is interrupted, such as by closing and reopening a laptop
(c) Using persistent connections is always faster than non-persistent connections, because there is less overhead
(d) Using non-persistent connections can be faster because they allow more parallelism than persistent connections

d ->

1. What are three advantages of UDP over TCP? (1 mark)
(a) No need for set up
(b) packets not held up if one is lost (c) No congestion control


2. What are three advantages of TCP over UDP? (1 mark)
(a) Congestion control
(b) Reliability
(c) Application doesn’t need to split messages into data chunks


3. What are the differences between SMTP and HTTP? (2 marks)
(i) SMTP is a push protocol, while HTTP is a pull protocol; 
(ii) SMTP requires all the contents in message to be in 7-bit ASCII format, 
while HTTP has no such a restriction; (iii) HTTP sends objects in a “one-in-one” manner, 
namely, each object is sent via a message. However, 
STMP sends objects in a “all-in-one” manner, i.e., sending all the objects in one message.


4. TCP allows the use of “delayed ACKs”. That halves the number of ACK packets 
sent by sending an ACK only every second packet (or after a short timeout). 
What impact will delayed ACKs have on slow start? (2 marks)

Slow start increases cwnd once per ACK, and so it would halve the rate of increase on cwnd size

5. Suppose Host A sends three TCP segments back to back to Host B over a TCP connection. 
The sequence numbers of these three segments are 13, 73 and 123, respectively. 
Host B also sends three segments to Host A with sequence numbers of 20, 60 and 80, respectively.

(a) How many bytes are there in the data field of the second segment sent by A? (1 mark)
(b) Suppose that when A’s first segment arrives to B, and B then sends its first segment to A.
What are the values of seq and ack in B’s first segment? (1 mark)
(c) Suppose that A’s second segment is lost and A’s third segment arrives to B, and B then sends its second segment to A. What are the values of seq and ack in B’s second segment? (1 mark)
(d) Upon the arrival of B’s second segment, Host A retransmits its second segment. What are the values of seq and ack in this retransmission? (1 mark)

(a) 50; (b) seq = 20,ack = 73; (c)seq = 60,ack = 73; (asking A to send 73 again) (d) seq = 73,ack = 80. (as the second segment is stil lost, retransmit
ack=80 because there's still B's 80 left to be transmitted)


--------------------------------------------------------------------------------
Revision

Two types of FTP connections:

Uses two parallel TCP connections to transfer a file.

Control connection -> sending control info betw' the two hosts (client and server)
-> user info, password, commands to change remote directory

Data connection -> used to send files

Principal components of protocols:
1, the format of messages
2, orders of the messages to be communicated
3, actions taken on the tramsmission of a message

3 things that reliable transfers guarantee:
1, integrity (no data loss or change)
2, order
3, segment delivery (successful delivery)


ack and seq:




