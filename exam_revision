week 8

Sender and receiver know the same secret key in symmetric systems. Therefore, the same secret key is 
used for both encryption and decryption.

-> sender chooses a secret key to encrypt a plain text, and the recipent uses the same key to decrypt the cipher text.

Encryption and decryption keys are different in public key systems. The encryption key is known by everyone including the sender, 
but the decryption key is only known by the receiver.

-> Receiver first creates its own public and private keys, where the former is open to everyone but the latter is hidden.
Sender uses the former (public key created by the receiver, which is open to everyone) to encrypt a plain text. 
Recipent can decrypt and open the cyphertext encrypted using the public key by sender, with its private key.

If N people want to communicate with each of N-1 other people using symmetric key encryption, each pair of users must have a
shared symmetric key, that is N * (N-1) / 2 keys.

-> N people want to communicate with N-1 other people, and symmetric key encryption uses the same secret key for both encryption
and decrypiton, so N * N -1. Since we only need the same key for one pair, remove duplicates by diving it by 2.

With a public key system (also known as assymetric crypto)

-> Everyone user should have two keys, including one public key which is open to 
everyone and the other which is onlu known by the user. Anyone can use the user's public key to encrypt a plain text, and 
the user can use its own private key to decrypt the cyphertext.

Therefore, every user would need 2 keys for encryption and decryption.
So 2N keys required.

AES is an symmetric cryptography algo'. 
-> The same secret key is used for encryption and decryption. 
Key to sign is the same as the key to verify

AES is less suitable for digital signatures than RSA (public key systems).
-> It is less suitable because digital signatures should only be forged or created by one user, but
in symmetric system, it uses the same secret key, and thus can be used for both verification and creation of signatures.

Asymmetric key crypto is not used to encrypt actual messages.
-> Because it is slower than symmetric. Not suitable for encrypting large amounts of data. Can
only encrypt data up to the sie of the key. As it needs to first encrypt using the public key(which is open to everyone 
and private key to decrypt, where as with symmetric can just use a single key for both, which simplifies
the entire system)

Asymmetric key crypto (public key system. Different keys for encryption and decryption) is 
usually used with symmetric key crypto to encrypt messages.
-> it is used to exchanging a joint secret key for symmetric system.

The entire process would look like
Alice generates her key pair and posts her public key online.
Bob generates a secret key and encrypts his secret key using Alice's public key (public key is always
used to encrypt in public key system)
Bob sends the encrypted text to Alice
Alice uses her own private key to decrypt Bob's encrypted secret key.
Now Alice and Bob share the secret key. This means that secret key is shared in an encrypted way,
and the key can be used as the key for both encryption and decryption of messages between alice and bob.

Degital Ceritifcate is the fundamental job of a certificate in order to bind a public key to 
the name of someone (individual or company). 
It includes details about the owner, information about the public
key, and the signature of the certifying authority.

-> It is a set of information including the public key, owner, and the digital signature.

Suppose certifier.com creates a certificate for foo.com. The entire certificate would be encrypted with 
certifier.com's public key. 

-> False. Ceritifcates need to be distinct so needs to include some data of foo.com, which could be 
a hash of foo.com's information (including its public key), and signed with certifier.com's private key.
As public key is always open to everyone. Needs to sign with private key to certify.

Diffie Hellman key exchange is used for sharing a secret key between two users. p and g are already fixed.
*g must be smaller than p. Because it's modulo p. P must be a prime number.
The secret key chosen by each user is user to power g. e.g. if secret key is 4. g^4 but p always stays
the same, and it's used for modulo p.

Alice and Bob share the secret key as follows:
Alice sends p, g and A's computed public key (g^x mod p where is a secret key) in the tuple
(227, 5, 82), where x = 12. 

Bob finds x by reverse engineering
the g^x mod p sent by Alice, this can be done by manually inserting a value into x
until it finds a value 82, 5^x mod 227 = 82). -> Bob now has Alice's secret key.

Bob sends 125 (g^y mod p) where y is the secret key Bob chose = 3.

Alice sends g^b^a mod p = 5^12^3 mod 227 = 212, after doing the same step as Bob did to find her secret key.

The secret key in the endis g^b^a mod p = 5^12^3 mod 227

RSA asymmetric cryptography uses powers of large numbers modulo a third number, like
Diffie-Hellman key exchange. 

-> Encryption consists of calculating m^e(mod n).
e and n are the variables and m is the plaintext.

-> Decrypting ciphertext c consists of calculating c^d (mod n) 
private key consits d and n excluding the cyphertext

-> always decrypt to the correct plaintext.
e.g. encrypt the message 6 with the key (e = 3, n=55, they are any integers)
Decrypt the cipher text with (d=7, n=55). n has to be the same but d can be any secret integer.
The decoded message is ciphertext^decryption key ≡ plaintext^encrption key^decryption key ≡ 
Original message.


Alice wants to communicate with Bob, using public-key system (assymetric, public key and private key). 
She establishes a connection to someone she hopes is Bob. Alice gets Bob's public key(encryption key) through
plaintext along with an X.509 certificate signed by the root CA. 
Alice already has the public key of the root CA. 

-> Alice checks if it's Bob by Step 1 is to verify the X.509 certicate using the root CAs public key (
alrady has the public key of the root CA and needs to verify the bob's public using the x.509 certificate). 
If it is genuine, she now has Bob’s public key, although she should check the CRL (certificate revocation list) if
there is one. 

-> To see if it is Bob on the other end of the connection, she needs to know
if Bob has the corresponding private key. She picks a nonce (essentially a random number
used once) and sends it to him with his public key. If Bob can send it back in plaintext, she
is convinced that it is Bob. As Bob needs to decrypt with his private key.
So all she needs is use Bob's public to encrypt that is done through¥ the certificate, and then send a 
random number in an encrypted way and let him decrypt.

In, PKI based on a tree-structured hierarchy of CAs, Alice wants
to communicate with Bob, and receives a certificate from Bob signed by a CA X after
establishing a communication channel with Bob. Alice has never heard of X.

-> First Alice establishes a communication channel with X and asks X for a certificate to verify
his public key (when verifying
always need to first verify the authority of the certificate, public key)
X provides a certificate signed by another CA Y. Alice does not
know Y, she first does it with Y.
Alice continues to do this, until she receives a certificate verifying the public key of a CA
Z signed by A and Alice knows As public key. 
After this Alice verifies the public keys in reverse order
starting from the certificate that Z provided. In each step during verification, she also checks
the CRL to make sure that the certificate provided have not been revoked. Finally, after
verifying Bobs public key, Alice ensures that she is indeed talking to Bob using the same
method as in the previous problem.

Salt can be addded to plaintext in the following ways:
The salt could be arithmetically added to the plaintext, 
treating both binary strings as numbers. A con is that this requires carry over many bytes.

The salt could be appended or prepended to the plaintext. An advantage is that this works
with arbitrary length plaintexts. A disadvantage is that this makes the plaintext longer, which
increases computation of encryption and decryption substantially. 
If the text is in block shape, then some blocks may not be protected at all.

Describe the TLS (transport layer security, responsible for the authentication and key exchange 
necessary to establish) Handshake process.
(a) First TCP connection (always need a TCP connection to begin with, otherwise no connection between them)
(b) Client (always start with a client) sends clienthello and asks the server for secure connection,
listing its supported cipher suites (signature, encryption method and so on).
(c) Server responds with ServerHello and selects one of the cipher
suites presented that it supports, also includes its certificate, and
can request the client send its certificate (mutual authentication)
(d) Client confirms validity of certificate (receving the server certificate) Once the certificates are valid, do key exchange
(e) Client generates session key -> can do in two ways
i. Picking a random key and encrypting it with the public key of the
server (alway use the opponet's public key to encrypt)
ii. Running the Diffie-Hellman Key Exchange protocol that provides better security
(f ) Handshake concludes and both parties share a key that is then used for encrypting/decrypting
messages

---------------------------------------------------------------

week 9

Routers have IP addresses

-> One address for each router/interface typically. No two interfaces can have the same address, 
but possible to have multiple addresses or no IP address if it's not connected to the internet.

Two hosts have IP addresses 192.200.20.5 and 192.200.100.5.
(a) If each is on a /24 network, are they on the same network?

-> No. /24 = 24 bits. Read from the left. 3 decimals are used to represent 8.

(b) If each is on a /20 network, are they on the same network?
 
 -> No. /20 = 20 bits.

(c) If each is on a /17 network, are they on the same network?

-> Yes 17 bits reading from the left. Differ in 20 and 100 part.
This case break them down into binary from decimal. 20 = 1010 (16 + 4), 100 = 110010  (64 + 32 + 4)
so the first bit of those are the same, which means exactly 17 bits are the same.

(d) if each is on a /14 network, are they on the same network?

-> Yes reading decimals from the left, it's obviously true.


Datagram networks route each packet as a separate unit, independent of
all others, as the name says datagram (piece of data). 

In virtual-circuit networks, each data packet follows a predetermined route (as circuits are usually defined)
-> Virtual-circuit networks need the capability to route isolated
packets from an arbitrary source to an arbitrary destination, in order to
route connection setup packets from an arbitrary source to an arbitrary
destination.

A network on the Internet has a subnet mask of 255.255.240.0. 

-> the maximum number of hosts it can handle is 4094.

Use HOST ID to calculate this. NET ID for 20, leave 12 bits for HOST ID (IP address is 32 bits, 4sets of 3 decimals)
NET ID is always 20. So 12 bits are available.

-> The binary representation of the subnet mask consists of 20 ones followed
by zeroes. Change the decimal to binary rep.
11111111_11111111_11110000_00000000

This means that the mask is 20 bits long, so the network part
is 20 bits. (The total/ip address is 32 bit long) 
The remaining 12 bits are for the host, so 2^12 = 4096 host addresses exist.
*It's the maximum num it can allocate.

A router received routes to the following new IP networks: 57.6.96.0/21,
57.6.104.0/21, 57.6.112.0/21, and 57.6.120.0/21. All of them are routed
on the same outgoing line. They can be aggregated.

-> They can be aggregated to 57.6.96.0/19 (the network parts of the addresses
that use the same outgoing line are the same up to 19 bits.)

*A Subnet mask is a 32-bit number that masks an IP address, 
and divides the IP address into network address and host address. Subnet musk has network and host address. 20 for network and 12 for the host.

Prefix: substring 21 bit system. But one set of decimals/decimal always have 8 bits.


57.6.96.0/21 00111001 00000110 01100000 00000000
57.6.104.0/21 00111001 00000110 01101000 00000000
57.6.112.0/21 00111001 00000110 01110000 00000000
57.6.120.0/21 00111001 00000110 01111000 00000000

Since it is the same until the third set of 011. It is the most optimal address.
So it has 19 bits and leave the rest zeros, and thus 57.6.96.0/19.

A large number of consecutive IP addresses are available starting at 198.16.0.0.
Four organizations, A, B, C, and D, request 4000, 2000, 4000,8000 addresses, 
respectively, and in that order. Each is allocated the lowest available IP addresses. 

The first IP address assigned, the last IP address assigned, and the mask in the
w.x.y.z/s notation of these are:
-> think how many bits it would need to request those numbers of addresses

A: 4000 addresses require 12 bits (2^10 = 1024, 1024 * 2 * 2 = 2^12), so 
198.16.0.0 – 198.16.15.255 (11000110.00010000.00001111.11111111, 12 bits extra 00001111 is 15
, 11111111 becomes 255) written as 198.16.0.0/20 (need 32 - 12 as it's the free part. so it becomes 198.16.0.0/20)

*reading binary (1010)2 can also be written as follows: (1 * 2^3) + (0 * 2^2) + (1 * 2^1) + (0 * 2^0)

B: 2000 addresses require 11 bits, so
198.16.16.0 – 198.16.23.255 written as (1024 * 2 = 2048, 11000110.00010000.00000111.11111111)
198.16.16.0/21 (-11 bits)

C: 4000 addresses require 12 bits, so (16, 32, 64 are because of the previous ranges already assigned for A and B
it goes up 16 decimal each time)
198.16.32.0 – 198.16.47.255 written as
198.16.32.0/20

D: 8000 addresses require 13 bits, so
198.16.64.0 – 198.16.95.255 written as
198.16.64.0/19



