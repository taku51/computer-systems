week 8

Sender and receiver know the same secret key in symmetric systems. Therefore, the same secret key is 
used for both encryption and decryption.

-> sender chooses a secret key to encrypt a plain text, and the recipent uses the same key to decrypt the cipher text.

Encryption and decryption keys are different in public key systems. The encryption key is known by everyone including the sender, 
but the decryption key is only known by the receiver.

-> Receiver first creates its own public and private keys, where the former is open to everyone but the latter is hidden.
Sender uses the former (public key created by the receiver, which is open to everyone) to encrypt a plain text. 
Recipent can decrypt and open the cyphertext encrypted using the public key by sender, with its private key.

If N people want to communicate with each of N-1 other people using symmetric key encryption, each pair of users must have a
shared symmetric key, that is N * (N-1) / 2 keys.

-> N people want to communicate with N-1 other people, and symmetric key encryption uses the same secret key for both encryption
and decrypiton, so N * N -1. Since we only need the same key for one pair, remove duplicates by diving it by 2.

With a public key system (also known as assymetric crypto)

-> Everyone user should have two keys, including one public key which is open to 
everyone and the other which is onlu known by the user. Anyone can use the user's public key to encrypt a plain text, and 
the user can use its own private key to decrypt the cyphertext.

Therefore, every user would need 2 keys for encryption and decryption.
So 2N keys required.

AES is an symmetric cryptography algo'. 
-> The same secret key is used for encryption and decryption. 
Key to sign is the same as the key to verify

AES is less suitable for digital signatures than RSA (public key systems).
-> It is less suitable because digital signatures should only be forged or created by one user, but
in symmetric system, it uses the same secret key, and thus can be used for both verification and creation of signatures.

Asymmetric key crypto is not used to encrypt actual messages.
-> Because it is slower than symmetric. Not suitable for encrypting large amounts of data. Can
only encrypt data up to the sie of the key. As it needs to first encrypt using the public key(which is open to everyone 
and private key to decrypt, where as with symmetric can just use a single key for both, which simplifies
the entire system)

Asymmetric key crypto (public key system. Different keys for encryption and decryption) is 
usually used with symmetric key crypto to encrypt messages.
-> it is used to exchanging a joint secret key for symmetric system.

The entire process would look like
Alice generates her key pair and posts her public key online.
Bob generates a secret key and encrypts his secret key using Alice's public key (public key is always
used to encrypt in public key system)
Bob sends the encrypted text to Alice
Alice uses her own private key to decrypt Bob's encrypted secret key.
Now Alice and Bob share the secret key. This means that secret key is shared in an encrypted way,
and the key can be used as the key for both encryption and decryption of messages between alice and bob.

Degital Ceritifcate is the fundamental job of a certificate in order to bind a public key to 
the name of someone (individual or company). 
It includes details about the owner, information about the public
key, and the signature of the certifying authority.

-> It is a set of information including the public key, owner, and the digital signature.

Suppose certifier.com creates a certificate for foo.com. The entire certificate would be encrypted with 
certifier.com's public key. 

-> False. Ceritifcates need to be distinct so needs to include some data of foo.com, which could be 
a hash of foo.com's information (including its public key), and signed with certifier.com's private key.
As public key is always open to everyone. Needs to sign with private key to certify.

Diffie Hellman key exchange is used for sharing a secret key between two users. p and g are already fixed.
*g must be smaller than p. Because it's modulo p. P must be a prime number.
The secret key chosen by each user is user to power g. e.g. if secret key is 4. g^4 but p always stays
the same, and it's used for modulo p.

Alice and Bob share the secret key as follows:
Alice sends p, g and A's computed public key (g^x mod p where is a secret key) in the tuple
(227, 5, 82), where x = 12. 

Bob finds x by reverse engineering
the g^x mod p sent by Alice, this can be done by manually inserting a value into x
until it finds a value 82, 5^x mod 227 = 82). -> Bob now has Alice's secret key.

Bob sends 125 (g^y mod p) where y is the secret key Bob chose = 3.

Alice sends g^b^a mod p = 5^12^3 mod 227 = 212, after doing the same step as Bob did to find her secret key.

The secret key in the endis g^b^a mod p = 5^12^3 mod 227

RSA asymmetric cryptography uses powers of large numbers modulo a third number, like
Diffie-Hellman key exchange. 

-> Encryption consists of calculating m^e(mod n).
e and n are the variables and m is the plaintext.

-> Decrypting ciphertext c consists of calculating c^d (mod n) 
private key consits d and n excluding the cyphertext

-> always decrypt to the correct plaintext.
e.g. encrypt the message 6 with the key (e = 3, n=55, they are any integers)
Decrypt the cipher text with (d=7, n=55). n has to be the same but d can be any secret integer.
The decoded message is ciphertext^decryption key ≡ plaintext^encrption key^decryption key ≡ 
Original message.


Alice wants to communicate with Bob, using public-key system (assymetric, public key and private key). 
She establishes a connection to someone she hopes is Bob. Alice gets Bob's public key(encryption key) through
plaintext along with an X.509 certificate signed by the root CA. 
Alice already has the public key of the root CA. 

-> Alice checks if it's Bob by Step 1 is to verify the X.509 certicate using the root CAs public key (
alrady has the public key of the root CA and needs to verify the bob's public using the x.509 certificate). 
If it is genuine, she now has Bob’s public key, although she should check the CRL (certificate revocation list) if
there is one. 

-> To see if it is Bob on the other end of the connection, she needs to know
if Bob has the corresponding private key. She picks a nonce (essentially a random number
used once) and sends it to him with his public key. If Bob can send it back in plaintext, she
is convinced that it is Bob. As Bob needs to decrypt with his private key.
So all she needs is use Bob's public to encrypt that is done through¥ the certificate, and then send a 
random number in an encrypted way and let him decrypt.

In, PKI based on a tree-structured hierarchy of CAs, Alice wants
to communicate with Bob, and receives a certificate from Bob signed by a CA X after
establishing a communication channel with Bob. Alice has never heard of X.

-> First Alice establishes a communication channel with X and asks X for a certificate to verify
his public key (when verifying
always need to first verify the authority of the certificate, public key)
X provides a certificate signed by another CA Y. Alice does not
know Y, she first does it with Y.
Alice continues to do this, until she receives a certificate verifying the public key of a CA
Z signed by A and Alice knows As public key. 
After this Alice verifies the public keys in reverse order
starting from the certificate that Z provided. In each step during verification, she also checks
the CRL to make sure that the certificate provided have not been revoked. Finally, after
verifying Bobs public key, Alice ensures that she is indeed talking to Bob using the same
method as in the previous problem.

Salt can be addded to plaintext in the following ways:
The salt could be arithmetically added to the plaintext, 
treating both binary strings as numbers. A con is that this requires carry over many bytes.

The salt could be appended or prepended to the plaintext. An advantage is that this works
with arbitrary length plaintexts. A disadvantage is that this makes the plaintext longer, which
increases computation of encryption and decryption substantially. 
If the text is in block shape, then some blocks may not be protected at all.

Describe the TLS (transport layer security, responsible for the authentication and key exchange 
necessary to establish) Handshake process.
(a) First TCP connection (always need a TCP connection to begin with, otherwise no connection between them)
(b) Client (always start with a client) sends clienthello and asks the server for secure connection,
listing its supported cipher suites (signature, encryption method and so on).
(c) Server responds with ServerHello and selects one of the cipher
suites presented that it supports, also includes its certificate, and
can request the client send its certificate (mutual authentication)
(d) Client confirms validity of certificate (receving the server certificate) Once the certificates are valid, do key exchange
(e) Client generates session key -> can do in two ways
i. Picking a random key and encrypting it with the public key of the
server (alway use the opponet's public key to encrypt)
ii. Running the Diffie-Hellman Key Exchange protocol that provides better security
(f ) Handshake concludes and both parties share a key that is then used for encrypting/decrypting
messages

---------------------------------------------------------------

week 9

Routers have IP addresses

-> One address for each router/interface typically. No two interfaces can have the same address, 
but possible to have multiple addresses or no IP address if it's not connected to the internet.

Two hosts have IP addresses 192.200.20.5 and 192.200.100.5.
(a) If each is on a /24 network, are they on the same network?

-> No. /24 = 24 bits. Read from the left. 3 decimals are used to represent 8.

(b) If each is on a /20 network, are they on the same network?
 
 -> No. /20 = 20 bits.

(c) If each is on a /17 network, are they on the same network?

-> Yes 17 bits reading from the left. Differ in 20 and 100 part.
This case break them down into binary from decimal. 20 = 1010 (16 + 4), 100 = 110010  (64 + 32 + 4)
so the first bit of those are the same, which means exactly 17 bits are the same.

(d) if each is on a /14 network, are they on the same network?

-> Yes reading decimals from the left, it's obviously true.


Datagram networks route each packet as a separate unit, independent of
all others, as the name says datagram (piece of data). 

In virtual-circuit networks, each data packet follows a predetermined route (as circuits are usually defined)
-> Virtual-circuit networks need the capability to route isolated
packets from an arbitrary source to an arbitrary destination, in order to
guide connection setup packets from an arbitrary source to an arbitrary
destination.

A network on the Internet has a subnet mask of 255.255.240.0. 

-> the maximum number of hosts it can handle is 4094.

Use HOST ID to calculate this. NET ID for 20, leave 12 bits for HOST ID (IP address is 32 bits, 4sets of 3 decimals)
NET ID is always 20. So 12 bits are available.

-> The binary representation of the subnet mask consists of 20 ones followed
by zeroes. Change the decimal to binary rep.
11111111_11111111_11110000_00000000

This means that the mask is 20 bits long, so the network part
is 20 bits. (The total/ip address is 32 bit long) 
The remaining 12 bits are for the host, so 2^12 = 4096 host addresses exist.
*It's the maximum num it can allocate.

A router received routes to the following new IP networks: 57.6.96.0/21,
57.6.104.0/21, 57.6.112.0/21, and 57.6.120.0/21. All of them are routed
on the same outgoing line. They can be aggregated.

-> They can be aggregated to 57.6.96.0/19 (the network parts of the addresses
that use the same outgoing line are the same up to 19 bits.)

*A Subnet mask is a 32-bit number that masks an IP address, 
and divides the IP address into network address and host address. Subnet musk has network and host address. 20 for network and 12 for the host.

Prefix: substring 21 bit system. But one set of decimals/decimal always have 8 bits.


57.6.96.0/21 00111001 00000110 01100000 00000000
57.6.104.0/21 00111001 00000110 01101000 00000000
57.6.112.0/21 00111001 00000110 01110000 00000000
57.6.120.0/21 00111001 00000110 01111000 00000000

Since it is the same until the third set of 011. It is the most optimal address.
So it has 19 bits and leave the rest zeros, and thus 57.6.96.0/19.

A large number of consecutive IP addresses are available starting at 198.16.0.0.
Four organizations, A, B, C, and D, request 4000, 2000, 4000,8000 addresses, 
respectively, and in that order. Each is allocated the lowest available IP addresses. 

The first IP address assigned, the last IP address assigned, and the mask in the
w.x.y.z/s notation of these are:
-> think how many bits it would need to request those numbers of addresses

A: 4000 addresses require 12 bits (2^10 = 1024, 1024 * 2 * 2 = 2^12), so 
198.16.0.0 – 198.16.15.255 (11000110.00010000.00001111.11111111, 12 bits extra 00001111 is 15
, 11111111 becomes 255) written as 198.16.0.0/20 (need 32 - 12 as it's the free part. so it becomes 198.16.0.0/20)

*reading binary (1010)2 can also be written as follows: (1 * 2^3) + (0 * 2^2) + (1 * 2^1) + (0 * 2^0)

B: 2000 addresses require 11 bits, so
198.16.16.0 – 198.16.23.255 written as (1024 * 2 = 2048, 11000110.00010000.00000111.11111111)
198.16.16.0/21 (-11 bits)

C: 4000 addresses require 12 bits, so (16, 32, 64 are because of the previous ranges already assigned for A and B
it goes up always a decimal value of 16 each time)
198.16.32.0 – 198.16.47.255 written as
198.16.32.0/20

D: 8000 addresses require 13 bits, so
198.16.64.0 – 198.16.95.255 written as
198.16.64.0/19

A router has the following (CIDR) entries in its routing table (it shows how routing should be done, where it goes):

Address/mask Next hop
135.46.56.0/22 Interface 0
135.46.60.0/22 Interface 1
192.53.40.0/23 Router 1
default Router 2

For each of the following IP addresses, the router passes to the next hop when a packet
with that address arrives.
(a) 135.46.63.10 -> interface 1 (as 135.46.60.0/22 covers 63.10)
(b) 135.46.57.14 -> interface 0 (135.46.60.0/22 covers 57.14)
(c) 135.46.52.2 -> router 2 (not covered by any of the ones in the routing table so go to the defualt one)
(d) 192.53.40.7 -> router 1 (Coveredd by 192.53.40.0/23)
(e) 192.53.56.7 -> router 2 (not covered by any of the ones in the routing table so go to the defualt one)


A host to send an IP packet with the wrong source IP address 
-> A host launching a denial-of-service attack may send packets with a spoofed
source address that corresponds to another host, in order to evade beig tracked out. -> to fake identity for denial
of service attack (DoS attack).


Two ways that this can adversely affect the legitimate
owner of that IP address are:

The legitimate owner may be blamed for the attack (exploited by the malicious entity.
blocked from sending legitimate traffic to the victim destination (get blacklisted)), and may
also receive unwanted return traffic (e.g., SYN-ACK or RST packets).


Consider a network with the following link costs. Find the shortest path
from A to B using Dijkstra’s algorithm.

\ A B C D E
A 0 – 1 2 4
B – 0 – 10 4
C 1 – 0 3 2
D 2 10 3 0 5
E 4 4 2 5 0

From A to B, so look at A first. As dijkstra follows the most optimal local path each turn, it first goes to
C. From C, E is the closest unvisited node so goes to E, and then B.
*it doesn't go to the same node again.

The shortest path is B-E-C-A.

The IP packet header includes a time-to-live field that is decremented by
each router along the path. (each turn it gets decremented)

-> The time-to-live field is necessary because a packet might get stuck in forwarding loop (e.g., due to a router configuration mistake, 
or the transients of a routing algorithm). By decrementing
the TTL (time to live) field at each hop, and discarding the packet when the TTL reaches 0, 
the network prevents the packet from being in an inifinate loop. 
Otherwise, it would consume excessive resources, or even escape the
loop eventually and reach the destination much later.

An ISP owns the block of addresses of the form 101.101.128.0/17.
It wants to create four subnets from this block, each block having
the same number of IP addresses. The prefixes (of form a.b.c.d/x)
for the four subnets are as follows: add 32 each time.

Four equalsize subnets:
need additional 2 digits to express 4 different patterns. So 17 ->19
101.101.128.0/17 single subnet 110.101.1(0000000.0/17)
so 
101.101.10000000.0/19 -> 101.101.128.0/19

101.101.10100000.0/19 -> 101.101.160.0/19

101.101.11000000.0/19 -> 101.101.192.0/19

101.101.11100000.0/19 -> 101.101.224.0/19


Consider the example of BGP (how the vendor map looks like, each of the nodes is an autonomous system):

(a) an Autonomous Sytem is a network that are collections of routers
under the same administrative control (network which contains routers under the same control system). 
e.g. ISP network. Customers A, B, C own autonomous systems.

(b) A physical path exists between AS2 and AS3,
as well as between AS3 and AS4. A packet sent from C with
destination A cannot be sent from AS4 to AS3 to AS2.
-> The customer ISP typically only advertises routes for their network to avoid transiting other traffic 
(in this case, traffic destined to A).So cannot transit to other tranffic.

------------------------------------------------------------------
week 10:

Sending a 1500-byte datagram into a link that has an MTU
Maximum Transmission Unit of 500 bytes, can only send 1500 byte. 
The original datagram is stamped with the identification number 1. IPv4 is
used. Hint: The IPv4 header is 20 bytes long always.

Need to chunk into smaller because it's too big as the maximum is 500 bytes.

(a) Where does fragmentation happen? Where are the fragments reassembled?

Happens in the router preceding the link with the small
500 bytes MTU. Need to chunk into smaller.

Routers with small MTU -> necessity for fragmentation.
Pkts/fragments re-assembled (come together) at the end hosts/systems

(b) How many fragments are generated?

Since header always takes 20 bytes, the other 480 can carry the data, and thus 480 * 4 is needed.
1 is for anything else carrying (identification number).
480 * 3 + 1

+ 1 is for anything else carrying
60 left so another one fragment needed.

4 fragments in total 

(c) In addition to the identification number, what are the fields in the
generated IP datagram(s) that are related to fragmentation?

Flags (DF=Don’t Fragment and MF=More Fragments) and fragmentation offset. Need to set the flags.

(d) What are the values of the fragmentation-related fields in the generated IP datagram(s)?
Describe what it has and size.
Each fragment will have an identical identification number. Each
fragment except the last one will be of size 500 bytes (including the
IP header). The last datagram will be of size 80 bytes (including the
IP header, needs 60 bytes of data).

All fragments will have DF=0. Each of the first 3 fragments will have
MF=1 (tells whether to send more); the last fragment will have MF=0.

The offsets of the 4 fragments will be 0, 60, 120, 180. Note: all
fragments except the last one in a datagram must be a multiple of 8
bytes (the elementary fragment unit) 60 comes from the last data to be sent. and it doubles each time it's sent.

2. John’s home network consists of his laptop, smart phone and smart speaker.
(a) It is not likely that each of these devices will each have unique global IP
address.

-> Assigned by single global IP address
Manage devices in subnet (if they are close, will be in the same subnet) – internal routing (as they are in the same network)

(b) The network address of the home network is 192.168.1.0/24. Assign
addresses to all interfaces in the home network.

-> Just allocate internal IPs to each of the devices
192.168.1.1 ~ 102.168.1.x

It'll cover all devices within the same network(subnet).

(c) A widely used solution (as described in the lectures) which
allows several devices to share the same global IP address is:

NAT - Network address translation (by tnraslating it is possible.)

(d) John is a keen computer science student who is writing his own web
server. The key difficulty he will face when testing his server is:

Once an external user initiated a connection to the web server -> 404 (Web Server HTTP)
Manually set a NAT (network address translation) rule; mapping internal web server
to external address. -> Need to connect them between internal and external.

The difference between an application layer proxy and a NAT box are:

ALP proxy:
  App -> proxy -> Destination
 1 to 1 service: single proxy serves single Application.  (only 1 to 1 service)
  
Network Address Translation:
IP pkt level manipulations
Mapping external IP address to numbers of internal IP addresses

Acknowledgments used in 802.11 but not in wired Ethernet.

-> An 802.11 network due to the high rate of errors in wireless networks due to signal loss,
signal to noise ratio, fading, collisions, multi-path propagation and interference. 
If there were no acknowledgements sent back to the sender the sender 
would have no way of knowing that the receiver received the data intact and without error.

Wireless scenario: more likely losing pkts
wireless sender may not be capable of listening and sending at the same time.
Interference may occur without sender's awareness

5. The duration of a packet is less than the propagation delay
(round-trip time) from one side of a network to the other, CSMA (Carrier Sense Multiple access, listen before talk
if the router is not occupied by other devices, send packets)
does not provide performance benefit over Aloha.

ALOHA
  For end users: just send data no listening
  if ACKed, then done
  if collided: resend pkt after an arbitrary timeout
  Until pkt sent - ACK received
  
  Problems: 
  low throughput ^ avg 18% Network usage
  timeout mechanism - may have to wait several TO before timeout.


-> CSMA: listen before sending
Problems:
  More complicated implementation
  collision still not been fully solved
    -> 2 devices send pkts to router at the same time.
    
Minimise the cost when collided
CSMA/CA - CSMA with collision Avoidance
Contention window - Cwin, uniformly set at a random value initially
Workflow
  Idle channel -> counting down from Cwin
  if Cwin == 0 -> send a pkt (reset)
    if ACKed, done
    If not, Cwin = Cwin * 2, repeat (if ack is not received, then make the contention window larger, let it process faster and receive more data.)

-> The transmission passes through different locations at different times.
Knowing that there is a transmission here at the moment tells us very little
about whether or not there will be a transmission at our intended recipient
when our signal reaches there.

6. Aloha and Carrier sense multiple access differ in:

ALOHA: simpler, but lower TP
CSMA: better performance, but more complicated implementation

Dependency on e.g. Hardware
  Only poor performance provided: ALOHA may beat CSMA
  
-> CSMA has better perfo.  but aloha is simpler, In general, what is “best” at 
a given time and for a given application depends
on the cost/performance trade-off. Over time, more and more complex
systems become “best” as the cost of hardware decreases.

7. If CSMA was phased out of ethernet decades ago, why is it still used in
WiFi?

Wifi: based on broadcasting, manipulates over a shared medium (many people share) -> so no wireless equivalent to switched ethernet.
Ethernet: point to point connection (cables), no need to severely negotiate with other hosts. as it's point to point connection.

----------------------------------------------------------

week 11

Modern ethernet is still “ethernet” from the software point of view, except faster. 

-> It has the same frame format and broadcast address. It still doesn’t require the hosts to consider routing. It is
still connectionless.

-> It no longer uses a shared medium (“ether”). This has the following consequences. It no
longer uses CSMA/CD. It is no longer half duplex. It no longer has a limit on segment
lengths (free lengths and no duplex and no CSMA and NO share medium in the modern system).

Another, less fundamental, change is that many implementations allow ”jumbo frames” of
around 8000 bytes. So faster.

Rank the following in order of speed, from slowest to fastest.
(a) A single segment of 100 Mbps CSMA/CD ethernet (“Fast ethernet”)
(b) Switched 100 Mbps ethernet
(c) The same number of hosts as above on three “Fast ethernet” segments, connected by
bridges (Bridged CSMA/CD)
(d) Switched 10 Mbps ethernet

CSMA/CD is slower than bridged CSMA/CD, which is slower than switched ethernet for a
given bit rate. 

Switched ethernet -> bridged -> CSMA/CD

It is hard to quantify how much, depends on the load.
Usually switched 10 Mbps ethernet is slower than 100 Mbps CSMA/CD if there are fewer than
10 stations. If the load is near 100 Mbps then Fast ethernet will suffer congestion
collapse and have nearly zero throughput while 10 Mbps switched ethernet will continue to
give up to 10 Mbps to each station. Give up to 10 Mbps each station for stitwch ethernet.


Until about a decade ago, CPU manufacturers used to advertise the clock speed 
prominently, but they no longer do.

-> Each step of the pipeline takes one clock cycle. If the clock frequency is doubled then the
length of a clock cycle is halved (as processes faster), and 
so performance seems to be directly proportional to the clock speed

However, the amount of work done in each clock cycle (how much each cycle can process) 
is different for different CPUs. 
Instructions can take more or fewer cycles. More or fewer instructions can be issued per cycle.
Pipelines can stall more or less. Branches can be correctly predicted more or less often

A CPU takes 0.6 ns to or write read up to 16 bytes from RAM and 0.7 ns
to interpret an op-code and work out how to execute it. Most instructions take less than
0.5 ns to execute (excluding fetch, decode and writeback), but one takes 1.3 ns to complete.

(a) The fastest clock speed (in MHz or GHz) that the CPU can operate at is:

-> 0.77 × 109 Hz, or 0.77 GHz or 770 MHz.

-> The maximum time for each of the fetch/decode/execute/writeback stages (one of them) is τ = 1.3 ns(nano seconds),
which is 1.3 × 10^-9 seconds. If the pipeline moves by one stage per clock cycle (which
is usual, but not necessary), then the clock period must be at least this value. The clock
frequency is the reciprocal of the period (simply divide 1). That is f = 1/τ = 0.77 × 109 Hz, or 0.77 GHz
or 770 MHz.

(b) The slow instruction can be removed from the instruction set. The fastest clock
speed the CPU can operate at is:

-> Without the slow instruction (without 1.3), the maximum time is 0.7 ns. This gives f = 1/(0.7 ×
10^−9) = 1.4 × 109 Hz, or 1.4 GHz. (divide 1 by the time)

(c) The slow instruction is vital. Other approaches could be taken to allow the CPU
to operate at the faster clock speed are:

-> One approach would be to stall (extend time) the remainder of the pipeline while the long instruction
executes (cannot process at once so 
reducing the time moving from one pipeline to another), 
allowing it to take two clock cycles. A similar approach would be to cause the
CPU to throw out the other instructions later in the pipeline to allow the instruction to
complete, and then start the pipeline again afterwards. This is slower, but may result
in simpler hardware.

Identify the micro-ops you think would be required for each instruction in the int i=1;
example
pushq %rbp (a) Decrement rsp by 8. (b) save rbp to location pointed to by rsp
movq %rsp, %rbp Single µop
movl $1, -4(%rbp) (a) Compute rbp-4, and store it in a micro-architectural register (call
it R1). (b) Read 4 bytes from location pointed to by R1 into micro-architectural register
R2. (c) Increment R2 by 1. (d) Store R2 into location pointed to by R1.
movl $0, %eax Single µop
popq %rbp (a) Load rbp from location pointed to by rsp. (b) Increment rsp by 8
ret This is essentially another pop operation. (a) Load PC from location pointed to by rsp.
(b) Increment rsp by 8.

An ALU (arithmetic logic unit) takes two operands and produces an arithmetic or logical
output, such as their sum. Other arithmetic or logical operations it could perform are:

subtract add-with-carry subtract-with-carry
multiply negate increment
bitwise AND bitwise OR bitwise XOR
bitwise NOT shift-left-one-bit shift-right-one-bit

-> Add-with-carry adds two numbers and then adds the ”carry” bit (as the least-significant
bit) from the flags register. It is mainly used for computing quantities too big to fit into one
register as it's carrying, but also allows ones-complement addition which you have used for calculating
UDP checksums. Subtract-with-carry subtracts one number from another, and then subtracts the carry bit.

-> Note that multiply is listed but divide is not. Division is more complex, and is often relegated
to the floating point unit.
Shift-left is equivalent to multiplication by two, unless the most significant bit was 1. Some
instructions shift the most significant bit into the carry flag.

Shift-right is equivalent to division by two. There are often two forms: one assuming the
number is signed and one assuming the number is unsigned.


The number of stages in a pipeline is called its depth. 
The advantages and disadvantages of a deep pipeline are:

-> In a deep pipeline, each stage only needs to do a tiny task. That often allows the clock period
to be very small (clock frequency to be high, lots of tiny tasks so it lowers the maximum time,
which means the clock frequency goes up).

-> However, the longer a pipeline is, the more likely it is to be interrupted. For example, it has
to stall when there is a data dependency (wait when referencing data), 
or flushed when there is a branch misprediction.


------------------------------------------------------


Mid-semester test
1. The Internet community (“TCP/IP model”) consider layers 5 and 6 to be “empty”; they do not add any processing, headers or messages. 
Is it possible for the network layer of a communication system to be empty?

(a) No, the network layer is the only layer of the stack that cannot be empty.
(b) Yes, a single point-to-point link like a USB cable can be seen as a communication system with no network layer
(c) Yes, the “network layer” refers to the actual network equipment (wires, routers), not a protocol
(d) No, without a network layer, data cannot go from one place to another

b ->　physical

2. What layer is DNS?
(a) Network; DNS concerns the naming of nodes, which is a network layer function
(b) Transport; DNS uses the network to provides service to the application layer, and so is a transport layer protocol
(c) Application; DNS is concerned with allowing the final application to use simple names
(d) Link; DNS provides a link between domain names and IP addresses

c -> ip to names but not link betw' names and IP addresses.

3. Which of the following is NOT a role of sockets in network programming?
(a) They are the interface between the transport layer and the application layer.
(b) A pair of sockets provides a connection between two peers at the application layer
(c) A socket can bypass the physical layer to allow an application to continue working when a cable gets cut.
(d) A socket can listen for attempts to connect to a particular TCP port.

c ->

4. What is multiplexing/demultiplexing, and how does it relate to the transport layer?
(a) Multiplexing/demultiplexing refers to sharing one resource between multiple uses; the transport demultiplexes a single network attachment (IP address) between multiple logical data flows
(b) Multiplexing/demultiplexing refers to being able to do more than one thing at once; the transport layer can send and receive data at the same time, which is a form of multiplexing
(c) Multiplexing/demultiplexing refers to requiring multiple numbers to identify something; a TCP connection is identified by (source address, source port, destination address, destination port)
(d) Multiplexing/demultiplexing refers to indexing things by sequence numbers; TCP uses multiplexing/demultiplexing to know which packets to retransmit when loss occurs

a ->

5. In SMTP, how does the receiver know when the header is finished?
(a) The header starts with a “Length” field saying how many bytes are in the header 
(b) The header starts with a “Length” field saying how many lines are in the header 
(c) The header ends with a “Bcc” field; after that is the message body
(d) The line after the header is the first blank line after the start of the message.

d ->

6. If an authoritative DNS server becomes unavailable, what happens?
(a) DNS will no longer work because no other DNS servers are authorized
(b) The hosts for which that server is authoritative will become unreachable, and all connec- tions to them will be broken
(c) Most things will keep working because the information in the authoritative server is prob- ably cached in other DNS servers, and an ongoing TCP connection does not need DNS
(d) DNS will stop working for the hosts for which this server is authoritative, but existing connections will continue.

c ->

7, Why are protocol “stacks” made of layers?
(a) Early designers wanted to break the coding tasks between teams, and the functionality assigned to each team is called a “layer”
(b) Layering is the only way to implement a network stack, because each module can only interact with two other modules
(c) Layering allows each protocol to hide some complexity from the higher layers to provide a simpler view of the network, but sometimes layers need to interact with layers they are not adjacent to
(d) A “layer” is any protocol that lays headers in front of packets; these headers are needed to tell other network entities what to do with the packet

c ->

8, TCP is a “reliable” protocol. That means
(a) It delivers to the receiver all of the packets that are sent by the sender
(b) TCP is not vulnerable to network devices that maliciously alter the contents of the data stream
(c) It doesn’t accidentally disconnect often; some implementations automatically reconnect if needed
(d) If packets are lost by the lower layers, it will keep retransmitting them until either they get through or the connection is broken

d ->

9. The URL foo://123.45.6.7/abc/def.jpg
(a) is not a valid URL
(b) is a valid URL telling a browser to contact host 123.45.6.7 with protocol “foo”
(c) says that there is a JPEG image file called def.jpg in folder abc at host 123.45.6.7 
(d) tells the browser to contact host 123.45.5.6 and try to access file abc/def.jpg

b -> 
If there's an IT address and protocol, can ignore the rest

10. HTTP can use persistent or non-persistent TCP connections.
(a) A non-persistent connection is a different type of TCP connection that doesn’t persist in retransmitting lost packets; these are better for streaming applications
(b) ApersistentTCPconnectionisatypeofTCPconnectionthatreconnectsiftheconnection is interrupted, such as by closing and reopening a laptop
(c) Using persistent connections is always faster than non-persistent connections, because there is less overhead
(d) Using non-persistent connections can be faster because they allow more parallelism than persistent connections

d ->

1. What are three advantages of UDP over TCP? (1 mark)
(a) No need for set up
(b) packets not held up if one is lost (c) No congestion control


2. What are three advantages of TCP over UDP? (1 mark)
(a) Congestion control
(b) Reliability
(c) Application doesn’t need to split messages into data chunks


3. What are the differences between SMTP and HTTP? (2 marks)
(i) SMTP is a push protocol, while HTTP is a pull protocol; 
(ii) SMTP requires all the contents in message to be in 7-bit ASCII format, 
while HTTP has no such a restriction; (iii) HTTP sends objects in a “one-in-one” manner, 
namely, each object is sent via a message. However, 
STMP sends objects in a “all-in-one” manner, i.e., sending all the objects in one message.


4. TCP allows the use of “delayed ACKs”. That halves the number of ACK packets 
sent by sending an ACK only every second packet (or after a short timeout). 
What impact will delayed ACKs have on slow start? (2 marks)

Slow start increases cwnd once per ACK, and so it would halve the rate of increase on cwnd size

5. Suppose Host A sends three TCP segments back to back to Host B over a TCP connection. 
The sequence numbers of these three segments are 13, 73 and 123, respectively. 
Host B also sends three segments to Host A with sequence numbers of 20, 60 and 80, respectively.

(a) How many bytes are there in the data field of the second segment sent by A? (1 mark)
(b) Suppose that when A’s first segment arrives to B, and B then sends its first segment to A.
What are the values of seq and ack in B’s first segment? (1 mark)
(c) Suppose that A’s second segment is lost and A’s third segment arrives to B, and B then sends its second segment to A. What are the values of seq and ack in B’s second segment? (1 mark)
(d) Upon the arrival of B’s second segment, Host A retransmits its second segment. What are the values of seq and ack in this retransmission? (1 mark)

(a) 50; (b) seq = 20,ack = 73; (c)seq = 60,ack = 73; (asking A to send 73 again) (d) seq = 73,ack = 80. (as the second segment is stil lost, retransmit
ack=80 because there's still B's 80 left to be transmitted)


--------------------------------------------------------------------------------
Revision

Two types of FTP connections:

Uses two parallel TCP connections to transfer a file.

Control connection -> sending control info betw' the two hosts (client and server)
-> user info, password, commands to change remote directory

Data connection -> used to send files

Principal components of protocols:
1, the format of messages
2, orders of the messages to be communicated
3, actions taken on the tramsmission of a message

3 things that reliable transfers guarantee:
1, integrity (no data loss or change)
2, order
3, segment delivery (successful delivery)


ack and seq:



1. Which of the OSI layers handles each of the following:
a) Dividing the transmitted bit stream into frames (chunking) -> Data Link Layer (it is after network layer, chunking data)
b) Determining which route through the subnet to use (whenever sees routing it's network layer) -> Network Layer
Psysical is internet cables and stuff.

2. True or false? Consider congestion control in TCP. When the timer expires
at the sender, the value of ssthresh (threshold) is set to one half of its previous value.

False not it's half of the previous value but half of the current value of the congestion window.
When Timer expires (not receiving the ack he/she wants for a long time), 
the ssthresh becomes half of the congestion window because congestion window tells the amount of data to be sent.
And if timer expires, it'll ask the sender to send his data again, so the speed of data to be sent needs to be slowed down.
That's why it becomes half of the cwnd size.


3. Consider the effect of using slow start on a line with a 10-msec round-trip
time and no congestion. The receive window is 24 kiB and the segment
size is 2 kiB. How long does it take before the first full window can be
sent? (Bonus: what is the difference between ki, Mi, Gi and k, M, G?)

The first bursts contain 2ki, 4ki, 8ki, and 16ki bytes, respectively. The
window size will grow to accommodate 24ki after 40,msec. The first full
window will have been sent after 40 ms plus the time to send 24ki bytes
(= 24ki/bitrate).


4. TCP waits until it has received three duplicate ACKs before performing
a fast retransmit. Why do you think the TCP designers chose not to
perform a fast retransmit after the first duplicate ACK for a segment is
received.

Packets can arrive out of order from the IP layer. So whenever an out of
order packet would be received it would generate a duplicate ACK and if
we perform retransmission after the first duplicate ACK it would lead the
sender to introduce too many redundant packets in the network.


5. Your friend states that the Transport Layer in routers does not need to
worry about in-order forwarding of packets when TCP is employed. Do
you agree with their statement? In in-order delivery, which layer receives
packets in order?

The friend is exhibiting a lack of understanding of the functions of each
layer. Ideally, routers are only responsible for network layer functions.
Transport layer protocols operate on each end host, and therefore any inorder delivery requirements will be satisfied by buffering segments at end
hosts and delivering them in order to the application layer.
(Nitty gritty: Real routers are not ideal. Real routers exhibit layering violations by looking into IP payloads to observe transport layer port numbers
to try to reduce out-of-order delivery of packets within a TCP flow to improve the performance of TCP, even though routers don’t themselves have
a “transport layer”.)

6. In what way does an encrypted message hash using public-key cryptography provide a better digital signature than an encrypted message?

A signed message digest is better in that one need only encrypt (using
the private key) a short message digest, rather than the entire message.
Since public key (asymmetric) encryption with a technique like RSA is
expensive, it’s more desirable to have to sign (encrypt) a small amount of
data than a larger amount of data.

7. Consider a subnet with prefix 128.119.40.128/26. Give an example of one
IP address (of form xxx.xxx.xxx.xxx) that can be assigned to this network.
Suppose an ISP owns the block of addresses of the form 128.119.40.64/26.
Suppose it wants to create four subnets from this block, with each block
having the same number of IP addresses. What are the prefixes (of form
a.b.c.d/x) for the four subnets?

Any IP address in range 128.119.40.128 to 128.119.40.191.
(Nitty gritty: Address 128.119.40.128 is reserved as the network address,
and cannot be used by any host. Address 128.119.40.191 is the broadcast address and cannot be used by any host. Thus answers in the range
128.119.40.129–128.119.40.190 are better than reserved addresses, depending on how “assigned” is interpreted.)
Four equal size subnets: 128.119.40.64/28, 128.119.40.80/28, 128.119.40.96/28,
128.119.40.112/28

8. Consider a router that interconnects three subnets: Subnet 1, Subnet 2,
and Subnet 3. Suppose all of the interfaces in each of these three subnets
are required to have the prefix 223.1.17/24. Also suppose that Subnet 1
is required to support up to 60 interfaces, Subnet 2 is to support up to 95
interfaces, and Subnet 3 is to support up to 13 interfaces. Provide three
network addresses (of the form a.b.c.d/x) that satisfy these constraints.

223.1.17.0/26
223.1.17.128/25
223.1.17.64/28 is one possible solution


